use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use pyo3::pyclass;
use std::collections::{HashMap, HashSet};
use numpy::{PyArray1, PyReadonlyArray2};
use fidget::context::{Context, Tree};
use fidget::var::Var;
use std::io::{BufReader, Cursor, Write};
use std::iter::Peekable;
use std::str::Chars;

use crate::fp_var::PyVar;
use crate::fp_expr::PyExpr;
use crate::fp_eval::{determine_backend, _evaluate_bulk_vm, _evaluate_bulk_jit};

#[pyclass(name = "SDFContext")]
pub struct PySDFContext {
    ctx: Context,
    nodes: HashMap<usize, fidget::context::Node>,
    trees: HashMap<usize, Tree>,
    node_vars: HashMap<usize, Var>,
    next_handle: usize,
}

#[pymethods]
impl PySDFContext {
    #[new]
    pub fn new() -> Self {
        PySDFContext {
            ctx: Context::new(),
            nodes: HashMap::new(),
            trees: HashMap::new(),
            node_vars: HashMap::new(),
            next_handle: 0,
        }
    }

    pub fn clear(&mut self) {
        self.ctx = Context::new();
        self.nodes.clear();
        self.trees.clear();
        self.node_vars.clear();
        self.next_handle = 0;
    }

    /// Import an SDFExpr into the context, returning a handle (int)
    pub fn import_expr(&mut self, expr: &PyExpr) -> usize {
        let node = self.ctx.import(&expr.tree);
        let handle = self.next_handle;
        self.nodes.insert(handle, node);
        self.trees.insert(handle, expr.tree.clone());
        self.next_handle += 1;
        handle
    }

    /// Create a variable node from a Var
    pub fn var(&mut self, var: &PyVar) -> usize {
        let node = self.ctx.var(var.var.clone());
        let handle = self.next_handle;
        self.nodes.insert(handle, node);
        self.node_vars.insert(handle, var.var.clone());
        self.next_handle += 1;
        handle
    }

    /// Get the Var for a given node handle (if it is a variable node)
    pub fn get_var(&self, handle: usize) -> PyResult<PyVar> {
        if let Some(var) = self.node_vars.get(&handle) {
            Ok(PyVar { var: var.clone(), name: None })
        } else {
            Err(PyValueError::new_err("Handle does not correspond to a variable node"))
        }
    }

    /// Import a VM format string and create a new SDFExpr.
    ///
    /// Args:
    ///     text: String in VM format
    ///
    /// Returns:
    ///     An SDF expression parsed from the VM format
    #[pyo3(text_signature = "(text)")]
    pub fn from_vm(&self, text: String) -> PyResult<PyExpr> {
        // Create a cursor from the string to use as a reader
        let cursor = Cursor::new(text);
        let reader = BufReader::new(cursor);
        
        // Use Fidget's built-in parser for VM format
        match Context::from_text(reader) {
            Ok((ctx, node)) => {
                // Convert the result to a PyExpr
                match ctx.export(node) {
                    Ok(tree) => {
                        // For now, we don't have a way to extract variable names from the VM format
                        // So we'll use default variable names
                        let mut var_names = HashMap::new();
                        
                        // Try to identify standard variables
                        if let Some(var) = tree.var() {
                            match var {
                                Var::X => { var_names.insert(var, "x".to_string()); },
                                Var::Y => { var_names.insert(var, "y".to_string()); },
                                Var::Z => { var_names.insert(var, "z".to_string()); },
                                _ => {}
                            }
                        }
                        
                        Ok(PyExpr { tree, var_names })
                    },
                    Err(e) => Err(PyValueError::new_err(format!("Failed to export tree: {}", e))),
                }
            },
            Err(e) => Err(PyValueError::new_err(format!("Failed to parse VM format: {}", e))),
        }
    }

    /// Convert an SDFExpr to VM format.
    ///
    /// Args:
    ///     expr: The SDF expression to convert
    ///
    /// Returns:
    ///     String representation in VM format
    #[pyo3(text_signature = "(expr)")]
    pub fn to_vm(&mut self, expr: &PyExpr) -> PyResult<String> {
        // Import the tree into our context
        let node = self.ctx.import(&expr.tree);
        
        // Create a string buffer for the VM format
        let mut output = Vec::new();
        
        // Write the header
        writeln!(output, "# Fidget VM format export").unwrap();
        writeln!(output, "# Generated by fidget-py").unwrap();
        
        // We need to reconstruct the VM representation by walking through the tree
        // and generating the appropriate lines
        let mut node_map: HashMap<*const fidget::context::Op, String> = HashMap::new();
        let mut next_id: u32 = 0;
        
        // Helper function to write a node and its dependencies
        fn write_node_vm(
            node: fidget::context::Node,
            ctx: &Context,
            output: &mut Vec<u8>,
            node_map: &mut HashMap<*const fidget::context::Op, String>,
            next_id: &mut u32,
            written: &mut HashSet<*const fidget::context::Op>,
            var_names: &HashMap<Var, String>
        ) -> PyResult<String> {
            let op = ctx.get_op(node).unwrap();
            let ptr = op as *const _;
            
            // If we've already written this node, just return its ID
            if let Some(id) = node_map.get(&ptr) {
                return Ok(id.clone());
            }
            
            // Generate a new ID for this node
            let id = format!("_{:x}", *next_id);
            *next_id += 1;
            node_map.insert(ptr, id.clone());
            
            // Write dependencies first
            match op {
                fidget::context::Op::Binary(_, a, b) => {
                    let a_id = write_node_vm(*a, ctx, output, node_map, next_id, written, var_names)?;
                    let b_id = write_node_vm(*b, ctx, output, node_map, next_id, written, var_names)?;
                    
                    // Only write the node if it hasn't been written yet
                    if !written.contains(&ptr) {
                        let op_name = match op {
                            fidget::context::Op::Binary(opcode, _, _) => {
                                match opcode {
                                    fidget::context::BinaryOpcode::Add => "add",
                                    fidget::context::BinaryOpcode::Sub => "sub",
                                    fidget::context::BinaryOpcode::Mul => "mul",
                                    fidget::context::BinaryOpcode::Div => "div",
                                    fidget::context::BinaryOpcode::Min => "min",
                                    fidget::context::BinaryOpcode::Max => "max",
                                    fidget::context::BinaryOpcode::Compare => "compare",
                                    fidget::context::BinaryOpcode::Mod => "mod",
                                    fidget::context::BinaryOpcode::And => "and",
                                    fidget::context::BinaryOpcode::Or => "or",
                                    fidget::context::BinaryOpcode::Atan => "atan2",
                                }
                            },
                            _ => unreachable!(),
                        };
                        
                        writeln!(output, "{} {} {} {}", id, op_name, a_id, b_id).unwrap();
                        written.insert(ptr);
                    }
                },
                fidget::context::Op::Unary(_, a) => {
                    let a_id = write_node_vm(*a, ctx, output, node_map, next_id, written, var_names)?;
                    
                    // Only write the node if it hasn't been written yet
                    if !written.contains(&ptr) {
                        let op_name = match op {
                            fidget::context::Op::Unary(opcode, _) => {
                                match opcode {
                                    fidget::context::UnaryOpcode::Neg => "neg",
                                    fidget::context::UnaryOpcode::Abs => "abs",
                                    fidget::context::UnaryOpcode::Recip => "recip",
                                    fidget::context::UnaryOpcode::Sqrt => "sqrt",
                                    fidget::context::UnaryOpcode::Square => "square",
                                    fidget::context::UnaryOpcode::Floor => "floor",
                                    fidget::context::UnaryOpcode::Ceil => "ceil",
                                    fidget::context::UnaryOpcode::Round => "round",
                                    fidget::context::UnaryOpcode::Sin => "sin",
                                    fidget::context::UnaryOpcode::Cos => "cos",
                                    fidget::context::UnaryOpcode::Tan => "tan",
                                    fidget::context::UnaryOpcode::Asin => "asin",
                                    fidget::context::UnaryOpcode::Acos => "acos",
                                    fidget::context::UnaryOpcode::Atan => "atan",
                                    fidget::context::UnaryOpcode::Exp => "exp",
                                    fidget::context::UnaryOpcode::Ln => "ln",
                                    fidget::context::UnaryOpcode::Not => "not",
                                }
                            },
                            _ => unreachable!(),
                        };
                        
                        writeln!(output, "{} {} {}", id, op_name, a_id).unwrap();
                        written.insert(ptr);
                    }
                },
                fidget::context::Op::Const(c) => {
                    // Only write the node if it hasn't been written yet
                    if !written.contains(&ptr) {
                        writeln!(output, "{} const {}", id, c.0).unwrap();
                        written.insert(ptr);
                    }
                },
                fidget::context::Op::Input(v) => {
                    // Only write the node if it hasn't been written yet
                    if !written.contains(&ptr) {
                        match v {
                            Var::X => writeln!(output, "{} var-x", id).unwrap(),
                            Var::Y => writeln!(output, "{} var-y", id).unwrap(),
                            Var::Z => writeln!(output, "{} var-z", id).unwrap(),
                            _ => {
                                // Check if we have a name for this variable
                                if let Some(name) = var_names.get(v) {
                                    // Use the variable name in the VM format
                                    writeln!(output, "{} var-{}", id, name).unwrap();
                                } else {
                                    // Fallback to var-custom if no name is available
                                    writeln!(output, "{} var-custom", id).unwrap();
                                }
                            },
                        }
                        written.insert(ptr);
                    }
                },
            }
            
            Ok(id)
        }
        
        // Write the tree
        let mut written = HashSet::new();
        write_node_vm(node, &self.ctx, &mut output, &mut node_map, &mut next_id, &mut written, &expr.var_names)?;
        
        // Convert the output to a string
        match String::from_utf8(output) {
            Ok(s) => Ok(s),
            Err(_) => Err(PyValueError::new_err("Failed to convert output to UTF-8 string")),
        }
    }

    /// Convert an SDFExpr to F-Rep format.
    ///
    /// Args:
    ///     expr: The SDF expression to convert
    ///
    /// Returns:
    ///     String representation in F-Rep format
    #[pyo3(text_signature = "(expr)")]
    pub fn to_frep(&self, expr: &PyExpr) -> PyResult<String> {
        // Fortunately, PyExpr already has a method to generate F-Rep strings
        Ok(expr.f_rep())
    }

    /// Import a F-Rep format string and create a new SDFExpr.
    ///
    /// Args:
    ///     text: String in F-Rep format
    ///
    /// Returns:
    ///     An SDF expression parsed from the F-Rep format
    pub fn from_frep(&self, text: String) -> PyResult<PyExpr> {
        // Create a new context for parsing
        let mut ctx = Context::new();
        
        // Parse the F-Rep format into a Fidget expression
        let mut parser = FRepParser::new(&text, &mut ctx);
        let node = parser.parse()?;
        
        // Export the node to a tree
        let tree = ctx.export(node).map_err(|e| PyValueError::new_err(e.to_string()))?;
        
        // Create a PyExpr from the tree
        Ok(PyExpr { tree, var_names: HashMap::new() })
    }

    /// Args:
    ///     handle: The handle of the imported expression.
    ///     values: A numpy array of shape (N, num_vars), where each row is a mapping of variable values.
    ///     variables: A list of Var objects corresponding to the columns of the array.
    ///     backend: Optional string specifying the backend ('vm' or 'jit'). Defaults to 'jit' if available, else 'vm'.
    ///
    /// Returns:
    ///     A numpy array of shape (N,) with the evaluation results.
    #[allow(clippy::too_many_arguments)]
    pub fn eval(
        &self,
        py: Python,
        handle: usize,
        values: PyReadonlyArray2<f32>,
        variables: Vec<PyVar>,
        backend: Option<String>,
    ) -> PyResult<Py<PyArray1<f32>>> {
        let tree = self.trees.get(&handle)
            .ok_or_else(|| PyValueError::new_err("Invalid handle for evaluation (handle must correspond to an imported expression)"))?;

        let use_jit = determine_backend(backend)?;

        let values_view = values.as_array();
        let rust_vars: Vec<Var> = variables.iter().map(|py_var| py_var.var.clone()).collect();

         let results = if use_jit {
             _evaluate_bulk_jit(tree, &values_view, &rust_vars)?
         } else {
             _evaluate_bulk_vm(tree, &values_view, &rust_vars)?
        };

        Ok(PyArray1::from_vec(py, results).into())
    }

}

/// A parser for F-Rep format strings
struct FRepParser<'a> {
    input: Peekable<Chars<'a>>,
    ctx: &'a mut Context,
}

impl<'a> FRepParser<'a> {
    /// Create a new F-Rep parser
    fn new(input: &'a str, ctx: &'a mut Context) -> Self {
        Self {
            input: input.chars().peekable(),
            ctx,
        }
    }
    
    /// Parse the input string into a Fidget expression
    fn parse(&mut self) -> PyResult<fidget::context::Node> {
        self.skip_whitespace();
        self.parse_expr()
    }
    
    /// Parse an expression
    fn parse_expr(&mut self) -> PyResult<fidget::context::Node> {
        self.skip_whitespace();
        
        // Check if the next token is a function name
        if let Some(c) = self.input.peek() {
            if c.is_alphabetic() {
                return self.parse_function_call();
            } else if c.is_numeric() || *c == '-' || *c == '.' {
                return self.parse_number();
            } else if *c == '(' {
                // Skip the opening parenthesis
                self.input.next();
                
                // Parse the expression inside the parentheses
                let expr = self.parse_expr()?;
                
                // Skip the closing parenthesis
                self.skip_whitespace();
                if let Some(')') = self.input.next() {
                    return Ok(expr);
                } else {
                    return Err(PyValueError::new_err("Expected closing parenthesis"));
                }
            }
        }
        
        Err(PyValueError::new_err("Unexpected token"))
    }
    
    /// Parse a function call
    fn parse_function_call(&mut self) -> PyResult<fidget::context::Node> {
        // Parse the function name
        let name = self.parse_identifier()?;
        
        self.skip_whitespace();
        
        // Check for opening parenthesis
        if let Some('(') = self.input.next() {
            // Parse the arguments
            let mut args = Vec::new();
            
            self.skip_whitespace();
            
            // Check if there are any arguments
            if let Some(')') = self.input.peek() {
                // No arguments
                self.input.next();
            } else {
                // Parse the first argument
                args.push(self.parse_expr()?);
                
                // Parse the rest of the arguments
                loop {
                    self.skip_whitespace();
                    
                    if let Some(')') = self.input.peek() {
                        // End of arguments
                        self.input.next();
                        break;
                    } else if let Some(',') = self.input.peek() {
                        // Skip the comma
                        self.input.next();
                        
                        // Parse the next argument
                        args.push(self.parse_expr()?);
                    } else {
                        return Err(PyValueError::new_err("Expected comma or closing parenthesis"));
                    }
                }
            }
            
            // Create the function call node
            match name.as_str() {
                // Binary operations
                "add" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("add requires 2 arguments"));
                    }
                    Ok(self.ctx.add(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "sub" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("sub requires 2 arguments"));
                    }
                    Ok(self.ctx.sub(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "mul" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("mul requires 2 arguments"));
                    }
                    Ok(self.ctx.mul(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "div" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("div requires 2 arguments"));
                    }
                    Ok(self.ctx.div(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "min" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("min requires 2 arguments"));
                    }
                    Ok(self.ctx.min(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "max" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("max requires 2 arguments"));
                    }
                    Ok(self.ctx.max(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "mod" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("mod requires 2 arguments"));
                    }
                    Ok(self.ctx.modulo(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "and" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("and requires 2 arguments"));
                    }
                    Ok(self.ctx.and(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "or" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("or requires 2 arguments"));
                    }
                    Ok(self.ctx.or(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "atan2" => {
                    if args.len() != 2 {
                        return Err(PyValueError::new_err("atan2 requires 2 arguments"));
                    }
                    Ok(self.ctx.atan2(args[0], args[1]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                
                // Unary operations
                "neg" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("neg requires 1 argument"));
                    }
                    Ok(self.ctx.neg(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "abs" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("abs requires 1 argument"));
                    }
                    Ok(self.ctx.abs(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "recip" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("recip requires 1 argument"));
                    }
                    Ok(self.ctx.recip(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "sqrt" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("sqrt requires 1 argument"));
                    }
                    Ok(self.ctx.sqrt(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "square" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("square requires 1 argument"));
                    }
                    Ok(self.ctx.square(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "floor" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("floor requires 1 argument"));
                    }
                    Ok(self.ctx.floor(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "ceil" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("ceil requires 1 argument"));
                    }
                    Ok(self.ctx.ceil(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "round" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("round requires 1 argument"));
                    }
                    Ok(self.ctx.round(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "sin" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("sin requires 1 argument"));
                    }
                    Ok(self.ctx.sin(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "cos" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("cos requires 1 argument"));
                    }
                    Ok(self.ctx.cos(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "tan" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("tan requires 1 argument"));
                    }
                    Ok(self.ctx.tan(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "asin" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("asin requires 1 argument"));
                    }
                    Ok(self.ctx.asin(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "acos" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("acos requires 1 argument"));
                    }
                    Ok(self.ctx.acos(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "atan" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("atan requires 1 argument"));
                    }
                    Ok(self.ctx.atan(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "exp" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("exp requires 1 argument"));
                    }
                    Ok(self.ctx.exp(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "ln" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("ln requires 1 argument"));
                    }
                    Ok(self.ctx.ln(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                "not" => {
                    if args.len() != 1 {
                        return Err(PyValueError::new_err("not requires 1 argument"));
                    }
                    Ok(self.ctx.not(args[0]).map_err(|e| PyValueError::new_err(e.to_string()))?)
                },
                
                // Unknown function
                _ => Err(PyValueError::new_err(format!("Unknown function: {}", name))),
            }
        } else {
            // No opening parenthesis, so this is a variable
            match name.as_str() {
                "x" | "X" => Ok(self.ctx.var(Var::X)),
                "y" | "Y" => Ok(self.ctx.var(Var::Y)),
                "z" | "Z" => Ok(self.ctx.var(Var::Z)),
                _ => Err(PyValueError::new_err(format!("Unknown variable: {}", name))),
            }
        }
    }
    
    /// Parse a number
    fn parse_number(&mut self) -> PyResult<fidget::context::Node> {
        let mut number = String::new();
        
        // Parse the sign
        if let Some('-') = self.input.peek() {
            number.push(self.input.next().unwrap());
        }
        
        // Parse the integer part
        while let Some(&c) = self.input.peek() {
            if c.is_numeric() {
                number.push(self.input.next().unwrap());
            } else {
                break;
            }
        }
        
        // Parse the decimal part
        if let Some('.') = self.input.peek() {
            number.push(self.input.next().unwrap());
            
            while let Some(&c) = self.input.peek() {
                if c.is_numeric() {
                    number.push(self.input.next().unwrap());
                } else {
                    break;
                }
            }
        }
        
        // Parse the exponent part
        if let Some(&c) = self.input.peek() {
            if c == 'e' || c == 'E' {
                number.push(self.input.next().unwrap());
                
                // Parse the exponent sign
                if let Some(&c) = self.input.peek() {
                    if c == '+' || c == '-' {
                        number.push(self.input.next().unwrap());
                    }
                }
                
                // Parse the exponent value
                let mut has_digits = false;
                while let Some(&c) = self.input.peek() {
                    if c.is_numeric() {
                        number.push(self.input.next().unwrap());
                        has_digits = true;
                    } else {
                        break;
                    }
                }
                
                if !has_digits {
                    return Err(PyValueError::new_err("Invalid number format: exponent has no digits"));
                }
            }
        }
        
        // Convert the string to a number
        match number.parse::<f64>() {
            Ok(value) => Ok(self.ctx.constant(value)),
            Err(_) => Err(PyValueError::new_err(format!("Invalid number format: {}", number))),
        }
    }
    
    /// Parse an identifier
    fn parse_identifier(&mut self) -> PyResult<String> {
        let mut identifier = String::new();
        
        // Parse the first character
        if let Some(&c) = self.input.peek() {
            if c.is_alphabetic() || c == '_' {
                identifier.push(self.input.next().unwrap());
            } else {
                return Err(PyValueError::new_err("Invalid identifier: must start with a letter or underscore"));
            }
        } else {
            return Err(PyValueError::new_err("Unexpected end of input"));
        }
        
        // Parse the rest of the identifier
        while let Some(&c) = self.input.peek() {
            if c.is_alphanumeric() || c == '_' {
                identifier.push(self.input.next().unwrap());
            } else {
                break;
            }
        }
        
        Ok(identifier)
    }
    
    /// Skip whitespace characters
    fn skip_whitespace(&mut self) {
        while let Some(&c) = self.input.peek() {
            if c.is_whitespace() {
                self.input.next();
            } else {
                break;
            }
        }
    }
}
